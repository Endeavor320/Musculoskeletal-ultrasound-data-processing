import cv2
import numpy as np
import math

# 加载图像
roi_image_path = r"C:\Users\Laity\Desktop\LiJinling_BS_LGM_BL.bmp"
roi_image = cv2.imread(roi_image_path, cv2.IMREAD_GRAYSCALE)

# === 第一步：图像预处理 ===
# 应用高斯模糊来减少噪声
blurred_image = cv2.GaussianBlur(roi_image, (5, 5), 0)

# 使用 Canny 边缘检测
edges = cv2.Canny(blurred_image, threshold1=50, threshold2=150)

# 找到轮廓
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# 创建彩色版本的图像用于绘制轮廓
output_image = cv2.cvtColor(roi_image, cv2.COLOR_GRAY2BGR)

# 绘制轮廓，使用浅灰色（200, 200, 200）并设置为 1 像素宽度
cv2.drawContours(output_image, contours, -1, (200, 200, 200), 1)  # 使用浅灰色绘制轮廓，降低干扰

# === 第二步：手动选择点 ===
points = []

# 鼠标点击事件回调函数
def select_points(event, x, y, flags, param):
    global points, output_image

    if event == cv2.EVENT_LBUTTONDOWN:
        # 每次点击鼠标左键，记录一个点
        points.append((x, y))
        # 在图像上绘制点
        cv2.circle(output_image, (x, y), 5, (0, 0, 255), -1)
        cv2.imshow("Select Points", output_image)

# 提示用户选择计算方式
print("请先选择上筋膜上的两个点，然后选择下筋膜上的两个点，最后选择肌束上的两个点。")

# 显示图像并设置鼠标回调函数
cv2.imshow("Select Points", output_image)
cv2.setMouseCallback("Select Points", select_points)
cv2.waitKey(0)
cv2.destroyAllWindows()

# === 第三步：计算羽状角和肌束长度 ===
# 确保正确选取了所需数量的点
if len(points) == 6:
    # 上筋膜上的两个点
    x1, y1 = points[0]
    x2, y2 = points[1]

    # 下筋膜上的两个点
    x3, y3 = points[2]
    x4, y4 = points[3]

    # 肌束上的两个点
    fx1, fy1 = points[4]
    fx2, fy2 = points[5]

    # === 计算下膜和肌束的方程并找到交汇点 ===
    # 计算下膜的斜率
    if (x4 - x3) != 0:
        m_lower = (y4 - y3) / (x4 - x3)
        b_lower = y3 - m_lower * x3
    else:
        m_lower = None  # 下膜垂直
        b_lower = None

    # 计算肌束的斜率
    if (fx2 - fx1) != 0:
        m_fascicle = (fy2 - fy1) / (fx2 - fx1)
        b_fascicle = fy1 - m_fascicle * fx1
    else:
        m_fascicle = None  # 肌束垂直
        b_fascicle = None

    # 求下膜和肌束的交汇点
    if m_lower is not None and m_fascicle is not None:
        # 两者都不是垂直线，求解 y = mx + b 的交点
        x_intersect = (b_fascicle - b_lower) / (m_lower - m_fascicle)
        y_intersect = m_lower * x_intersect + b_lower
    elif m_lower is None:
        # 下膜为垂直线，x 坐标固定为 x3
        x_intersect = x3
        y_intersect = m_fascicle * x_intersect + b_fascicle
    elif m_fascicle is None:
        # 肌束为垂直线，x 坐标固定为 fx1
        x_intersect = fx1
        y_intersect = m_lower * x_intersect + b_lower
    else:
        print("错误：无法找到交汇点，可能两条直线平行。")
        exit()

    print(f"下膜和肌束的交汇点坐标为: ({x_intersect:.2f}, {y_intersect:.2f})")

    # === 计算交汇点到上膜的垂直距离，并绘制垂线 ===
    # 使用上膜的第一个点 (x1, y1)
    if (x2 - x1) != 0:
        m_upper = (y2 - y1) / (x2 - x1)
        b_upper = y1 - m_upper * x1
        # 上膜的方程为 y = m_upper * x + b_upper
        A = -m_upper
        B = 1
        C = -b_upper
        h = abs(A * x_intersect + B * y_intersect + C) / math.sqrt(A**2 + B**2)

        # 计算垂线的终点坐标
        denom = (A**2 + B**2)
        x_perpendicular = (B * (B * x_intersect - A * y_intersect) - A * C) / denom
        y_perpendicular = (A * (-B * x_intersect + A * y_intersect) - B * C) / denom
        print(f"从交汇点到上膜的垂直距离 (h): {h:.2f} 像素")

        # 在图像上绘制垂线
        cv2.line(output_image, (int(x_intersect), int(y_intersect)), (int(x_perpendicular), int(y_perpendicular)), (0, 0, 255), 2)  # 红色线表示垂线
    else:
        # 如果上膜为垂直线，垂直距离即为 x 的差
        h = abs(x_intersect - x1)
        x_perpendicular, y_perpendicular = x1, y_intersect
        print(f'从交汇点到上膜的垂直距离 (h): {h:.2f} 像素')
        cv2.line(output_image, (int(x_intersect), int(y_intersect)), (int(x_perpendicular), int(y_perpendicular)), (0, 0, 255), 2)  # 红色线表示垂线

    # === 计算羽状角（夹角） ===
    pennation_angle = abs(math.atan2((fy2 - fy1), (fx2 - fx1)) - math.atan2((y2 - y1), (x2 - x1)))
    pennation_angle_deg = pennation_angle * (180.0 / np.pi)
    if pennation_angle_deg > 90:
        pennation_angle_deg = 180 - pennation_angle_deg
        pennation_angle = pennation_angle_deg * (np.pi / 180.0)  # 转换为弧度

    print(f'计算出的羽状角: {pennation_angle_deg:.2f} 度')

    # === 计算完整的肌束长度 (FL) ===
    if math.sin(pennation_angle) != 0:
        fascicle_length = h / math.sin(pennation_angle)
        print(f'计算出的完整肌束长度 (FL): {fascicle_length:.2f} 像素')
    else:
        print("无法计算肌束长度，羽状角为 0 度或过小，导致 sin(θ) 为 0。")

    # === 绘制标记和延长线 ===
    # 在图像上绘制上筋膜、下筋膜和肌纤维的直线
    cv2.line(output_image, (x1, y1), (x2, y2), (255, 0, 0), 2)  # 蓝色线表示上筋膜
    cv2.line(output_image, (x3, y3), (x4, y4), (0, 255, 255), 2)  # 黄色线表示下筋膜
    cv2.line(output_image, (fx1, fy1), (fx2, fy2), (0, 255, 0), 2)  # 绿色线表示肌纤维

    # 绘制延长线
    height, width = output_image.shape[:2]

    # 上膜延长线
    if m_upper is not None:
        x_upper1 = 0
        y_upper1 = int(b_upper)
        x_upper2 = width
        y_upper2 = int(m_upper * width + b_upper)
        cv2.line(output_image, (x_upper1, y_upper1), (x_upper2, y_upper2), (255, 0, 255), 1)  # 粉色线表示上膜延长线
    else:
        cv2.line(output_image, (x1, 0), (x1, height), (255, 0, 255), 1)  # 粉色线表示上膜延长线

    # 肌束延长线
    if m_fascicle is not None:
        x_fascicle1 = 0
        y_fascicle1 = int(b_fascicle)
        x_fascicle2 = width
        y_fascicle2 = int(m_fascicle * width + b_fascicle)
        cv2.line(output_image, (x_fascicle1, y_fascicle1), (x_fascicle2, y_fascicle2), (0, 255, 255), 1)  # 黄色线表示肌束延长线
    else:
        cv2.line(output_image, (fx1, 0), (fx1, height), (0, 255, 255), 1)  # 黄色线表示肌束延长线

    # 下膜延长线
    if m_lower is not None:
        x_lower1 = 0
        y_lower1 = int(b_lower)
        x_lower2 = width
        y_lower2 = int(m_lower * width + b_lower)
        cv2.line(output_image, (x_lower1, y_lower1), (x_lower2, y_lower2), (0, 0, 255), 1)  # 红色线表示下膜延长线
    else:
        cv2.line(output_image, (x3, 0), (x3, height), (0, 0, 255), 1)  # 红色线表示下膜延长线

    # 显示最终的图像
    cv2.imshow("Marked Image with Extended Lines and Perpendicular", output_image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    # 保存最终标记后的图像
    marked_image_path = r"C:\Users\Laity\Desktop\marked_ROI_with_lines_and_FL.bmp"
    cv2.imwrite(marked_image_path, output_image)
    print(f"标记后的图像已保存至 {marked_image_path}")
else:
    print("错误：必须选择上筋膜、下筋膜和肌纤维上的各两个点（共六个点）。")
